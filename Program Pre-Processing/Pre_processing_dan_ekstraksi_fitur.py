# -*- coding: utf-8 -*-
"""sub Pre-processing dan ekstraksi fitur final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BbZeoQBMdHu0wmOVc1uqumgwlo5QDXaE
"""

import pandas as pd
import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
import math

# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/cudb-cu01(VF).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/cudb-cu01(VF-2).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/cudb-cu04(Normal-VT).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/cudb-cu04(VT-VF).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/cudb-cu10(Pulseless%20VT-VF).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/cudb-cu6(VF).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/cudb-cu02(VT).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/vfdb-422(VF).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/vfdb-430(VF).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/vfdb-424(VF).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/vfdb-424(VF-2).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/vfdb-424(VF-3).txt'
# # link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/vfdb-609(VFL).txt'
# link = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Shockable/vfdb-612(VT).txt'

# data = pd.read_csv(link, delimiter = "\t")
# data

# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu17.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu01.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu08.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu14.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu16.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu18.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu05.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu07.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-424%20(asystole).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-424(2)%20(asystole).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-430%20(asystole).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-609(afib).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-609(afib-2).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-607(nodal).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu25.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu25-2.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu26.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu20.txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu10(Normal).txt'
url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu07(2).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu08(2).txt'
#ini testing jangan diambil buat training
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/cudb-cu02(R%20terbalik).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-427%20(asystole).txt'
# url = 'https://raw.githubusercontent.com/nadirras/signal-for-final-project2/main/Dataset%20(Belum%20di-Resample)/Non-Shockable/vfdb-607(asystole).txt'
data = pd.read_csv(url, delimiter = "\t")
data

"""# Resample"""

# DISCLAIMER: This function is copied from https://github.com/nwhitehead/swmixer/blob/master/swmixer.py, 
#             which was released under LGPL. 
def resample_by_interpolation(signal, input_fs, output_fs):

    scale = output_fs / input_fs
    # calculate new length of sample
    n = round(len(signal) * scale)

    # use linear interpolation
    # endpoint keyword means than linspace doesn't go all the way to 1.0
    # If it did, there are some off-by-one errors
    # e.g. scale=2.0, [1,2,3] should go to [1,1.5,2,2.5,3,3]
    # but with endpoint=True, we get [1,1.4,1.8,2.2,2.6,3]
    # Both are OK, but since resampling will often involve
    # exact ratios (i.e. for 44100 to 22050 or vice versa)
    # using endpoint=False gets less noise in the resampled sound
    resampled_signal = np.interp(
        np.linspace(0.0, 1.0, n, endpoint=False),  # where to interpret
        np.linspace(0.0, 1.0, len(signal), endpoint=False),  # known positions
        signal,  # known data points
    )
    return resampled_signal

scale = 200 / 250
n = round(len(data.ECG) * scale)

x = np.linspace(0, 10, len(data.ECG), endpoint=False)
y = data.ECG
# yre = scipy.signal.resample(data.ECG, 2500)
waktu = np.linspace(0, int(0.005*n), n, endpoint=False)
# interval = 1/200
# waktu = np.zeros(len(data.ECG))
# for t in range(0,len(data.ECG)):
#   waktu[t] = (t*interval)

# yre_polyphase = scipy.signal.resample_poly(y, 200, 250)
yre_interpolation = resample_by_interpolation(y, 250, 200)

plt.figure(figsize=(10, 6))
# plt.plot(data.Elapsed_time, data.ECG,'b', x, yre,'or-')
# plt.plot(xre, yre_polyphase, 'og-')
plt.plot(waktu, yre_interpolation, 'ok-')
plt.legend(['original signal', 'scipy.signal.resample', 'scipy.signal.resample_poly', 'interpolation method'], loc='lower left')
plt.show()

jumlahdata = len(yre_interpolation)
yy = yre_interpolation

"""# R Detection"""

#LPF
y1 = np.zeros(jumlahdata)
for n in range(12,jumlahdata):
  y1[n] = (2*y1[n-1])-y1[n-2]+yy[n]-(2*yy[n-6])+yy[n-12]


#HPF
y2 = np.zeros(jumlahdata)

for n in range(32,jumlahdata):
  y2[n] = 32*y1[n-16] - (y2[n-1]+y1[n]-y1[n-32])

#Derivative
y31 = np.zeros(jumlahdata)
y32 = np.zeros(jumlahdata)
y3 = np.zeros(jumlahdata)


for n in range(2,jumlahdata):
  y31[n] = (-y2[n-2]-2*y2[n-1])/8

for n in range(0,jumlahdata-2):
  y32[n] = (2*y2[n+1]+y2[n+2])/8

for n in range(2,jumlahdata-2):
  y3[n] = y31[n]+y32[n]


#Squaring
y4 = np.zeros(jumlahdata)

for n in range(0,jumlahdata):
  y4[n] = y3[n]*y3[n]

#Moving-Window Integration
y51 = np.zeros(jumlahdata)
y52 = np.zeros(jumlahdata)
N = 14
for i in range(0,jumlahdata):
  for ii in range(0,N):
    y51[i] = y51[i]+(y4[i-ii])
    y52[i] = y51[i]/N

# #Fiducial Marks
peaki = np.zeros(jumlahdata)
for i in range(5,jumlahdata-5):
  if y52[i] > y52[i-5]:
    if y52[i] > y52[i-4]:
      if y52[i] > y52[i-3]:
       if y52[i] > y52[i-2]:
        if y52[i] > y52[i-1]:
         if y52[i] > y52[i+1]:
          if y52[i] > y52[i+2]:
           if y52[i] > y52[i+3]:
            if y52[i] > y52[i+4]:
              if y52[i] > y52[i+5]:
                peaki[i] = 1 # peaki[i] = 1 kalau terdeteksi sebuah peak 
# pada titik i dan peaki[i] = 0 kalau tidak

#Initial Value of SPKI, NPKI, and Threshold
spki, npki, th1, th2 = np.zeros(jumlahdata), np.zeros(jumlahdata), np.zeros(jumlahdata),np.zeros(jumlahdata)
qrsi = np.zeros(jumlahdata)
pp =0
meann = 0
for i in range(0,400):
  if (y52[i] > pp):
    pp = y52[i]
    spki[0] = pp
  meann += y52[i]; 

mean_npki = meann/400;
npki[0] = mean_npki
#Initial Value of SPKI, NPKI, and Threshold
th1[0] = (npki[0] + 0.25 * (spki[0] - npki[0]))
th2[0] = 0.5*th1[0]
previous_peaki = -10000 #buat perbandingan pertama kali biar lebih kecil dari suatu variabe
peaki_interval = 0
tpeak =0
for i in range(1,jumlahdata): 
  spki[i] = spki[i-1]
  npki[i] = npki[i-1]
  th1[i] = th1[i-1]
  th2[i] = th2[i-1]
  if peaki[i] == 1:  # jika peaki[i] = 1 terdeteksi peak 
# peaki_interval = i - previous_peaki
# previous_peaki = i
# tpeak = peaki_interval*Tbaru
# print(peaki_interval,previous_peaki,tpeak,i)
    if y52[i] > th1[i]:
      peaki_interval = i - previous_peaki 
      previous_peaki = i #jadi ini nyimpen i sebelumnya, terus nanti di atas dikurangi sama i baru
      tpeak = peaki_interval*0.005
  # print(peaki_interval,previous_peaki,tpeak,i)
      if (tpeak > 0.2): #kalau tpeak (latensi) kurang dari 0.2 akan di-reject
      # if True:
        spki[i] = 0.875 * spki[i-1] + 0.125 * y52[i] #update signal level
        qrsi[i] = 1

      elif y52[i] >th2[i]:
        if (tpeak > 0.2):
        # if True:
          spki[i] = 0.75 * spki[i-1] + 0.25 * y52[i] #update signal level
          qrsi[i] = 1
      else:
        npki[i] = 0.875 * npki[i-1] + 0.125 * y52[i]  #update noise level
        qrsi[i] = 0
      th1[i] = (npki[i] + 0.25 * (spki[i] - npki[i])) #update thresholdnya
      th2[i] = 0.5*th1[i]
  # untuk deteksi fibrillatory complex    
    if (qrsi[i] == 0):
      if (peaki[i] == 1):
        if (y52[i] > th2[i]):
          if tpeak > 0.15 : 
            qrsi[i] = 1

# refractory period vf jadi cepat, 
# karena di vf stimulus awalnya lebih kuat dan paling mungkin terjadi pas di refractory period/ dispersion refractorynya meningkat, 
# artinya jd kurang dr 200 ms

qrsnd = np.zeros(jumlahdata)
for i in range(0, jumlahdata-27):
  qrsnd[i] = qrsi[i+27]
plt.rcParams["figure.figsize"] = (25,5)
plt.plot(waktu,yy*10000,label = 'yy')
# plt.plot(waktu,yre_interpolation*10000,label = 'yre_interpolation')
plt.plot(waktu,spki,label = 'spki')
plt.plot(waktu,npki, label = 'npki')
plt.plot(waktu,th1,label = 'th1')
plt.plot(waktu,th2, label = 'th2')
plt.plot(waktu,qrsnd*10000, label = 'qrsnd')
# plt.plot(waktu,qrsi*10000, label = 'qrsi')
plt.legend()

plt.rcParams["figure.figsize"] = (25,5)
plt.plot(waktu,y52,label = 'mwi')
# plt.plot(waktu,yre_interpolation*10000,label = 'yre_interpolation')
plt.plot(waktu,spki,label = 'spki')
plt.plot(waktu,npki, label = 'npki')
plt.plot(waktu,th1,label = 'th1')
plt.plot(waktu,th2, label = 'th2')
plt.plot(waktu,qrsi*10000, label = 'qrs')
# plt.plot(waktu,qrsi*10000, label = 'qrsi')
plt.legend()

"""# Ekstraksi Fitur"""

bpf = np.zeros(jumlahdata)
for i in range(2,jumlahdata):
   bpf[i] = (28*bpf[i-1]-14*bpf[i-2]+yy[i]-yy[i-2])/16

r_bpf = np.zeros(jumlahdata)
for i in range(0,jumlahdata-2):
  r_bpf[i] = qrsnd[i+2]


plt.plot(waktu,bpf,label = 'bpf')
# plt.plot(waktu,qrsnd,label = 'qrsnd')
plt.plot(waktu,r_bpf,label = 'r_bpf')
plt.legend()

def SegmentLength(searchstart, searchend, r_bpf):
  beat = 0
  start, end = 0, 0
  
  # Find Segment
  for i in range(searchstart,searchend):
    if r_bpf[i] == 1:
      beat += 1
      if beat == 1:
        start = i
      if beat == 2:
        end = i

  # Segment Length
  length = end - start
  
  # Check if length more than threshold
  # threshold = 500 
  # if length > threshold:
  #    return [0, end]
  # else:
  return [start, end]

# Loop per segment
segment = []
searchstart = 0
# searchend = jumlahdata
# count2 = np.zeros(20)
count1 = []
count2 = []
count3 = []
vari = 1
j = 0
num = 0
# den1 = 0
den2 = 0
num22=0
den22=0
hasil_lk=[]

while (vari!=0):
  
  segmentPoints = SegmentLength(searchstart, jumlahdata, r_bpf)
  start = segmentPoints[0]
  end = segmentPoints[1]
  # print(start,end)
  
  # print(11111)
  # print('segmentpoint=',segmentPoints)
  # print('segmentstart=',searchstart)
  if start != 0:       #kalau segmen = 0 belom ganemu apa apa, jadi bakal jalan terus
    if end == 0:
      vari = 0
    else:
      segment.append(segmentPoints) # array 3D
      # print(segment)
      length = end - start
      # print(length)

      #threshold untuk count2 (rata-rata)
      sumbpf = 0
      maxbpf = 0
      # absmd = 0
      # mdsignal = np.zeros(length)
      # sum_md = 0
      # x_md = np.zeros(length)
      for i in range(start,end):
        #count1
        if (bpf[i] > maxbpf):
          maxbpf = bpf[i]
        #count2
        absbpf = 0
        if bpf[i] > 0:
          absbpf = bpf[i]
        else:
          absbpf = -bpf[i]
        sumbpf = sumbpf + absbpf
      thres = sumbpf/length

      #Vf-Leak (Lk)
      for i in range(start,end):
        for j in range(start+i+1,end):
          if yy[i] > 0:
            absnum = yy[i]
          else:
            absnum = -yy[i]
          num += absnum

          # den1[j-i] = yy[i] - yy[j-1]
          if (yy[i] - yy[j-1]) > 0:
            absden = (yy[i] - yy[j-1])
          else:
            absden = -(yy[i] - yy[j-1])
          den2 += absden
     
          
          N = math.floor((np.pi*(num)/(den2))+1/2)
      # print(N)
      num2 = 0
      for i in range(start,end):
        for j in range(N+start,end):
          # num12[j-N] = yp[i] + yp[j-N]
          if yy[i] > 0:
            absnum2 = yy[i]
          else:
            absnum2= -yy[i]
          num2 += absnum2
          if (yy[i] + yy[j-N]) > 0:
            absnum2 = (yy[i] + yy[j-N])
          else:
            absnum2 = -(yy[i] + yy[j-N])
          num22 += absnum2
          # den12[i] = yp[j-N]
          if yy[j-N] > 0:
            absden2 = yy[j-N]
          else:
            absden2 = -yy[j-N]
          den22 += (absnum2+absden2)
          vf = num22/den22
      # hasil_lk.append(vf)


      # count2_zeros = np.zeros(length)
      count1_segment = 0
      # count3_segment = 0
      count2_segment = 0
      for i in range(start,end):
        if bpf[i] >= 0.5*maxbpf:  #range 0.5*max - max, bpf pasti nyentuh maxnya soalnya diatasnya
          count1_segment+=1
        if bpf[i] >= thres:       #range mean - max
          count2_segment+=1  #setiap ada yang diatas threshold dihitung ada berapa data poin   
      count1.append(count1_segment)
      count2.append(count2_segment)
      hasil_lk.append(vf)
  else:
    count1.append(0)
    count2.append(0)
    hasil_lk.append(0)

      # j+=1
  searchstart = end
      
print('count1=',count1)    
print('count2=', count2)
print('Lk=', hasil_lk)

cp = len(hasil_lk)

df5 = pd.DataFrame({'Count1': count1, 'Count2' : count2, 'Lk' : hasil_lk,
                         'Label' : [0]*cp})
df5

df5.to_csv('cudb-cu08(2).csv', index=False)

